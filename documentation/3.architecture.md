# **Project Architecture Guide**

This project follows a strict **Layered Architecture** (Data \-\> Domain \-\> Presentation) to ensure scalability, testability, and a clear separation of concerns.

## **1\. The Data Layer**

The Data Layer is responsible for fetching and mapping raw data from external sources.

### **DTO vs. Model**

* **DTO (Data Transfer Object):** Located in data/dto/. These represent the exact structure of the JSON returned by the API. They are volatile and should strictly match the backend contract.
* **Model:** Located in data/model/. These are internal representations of data used within the app. While often similar to DTOs, they can include helper methods or flatten complex API structures.

### **Remote Data Sources (Retrofit)**

All API calls are handled by **Retrofit**. Sources are defined as abstract classes in data/source/.

@RestApi()  
abstract class AuthSource {  
factory AuthSource(Dio dio) \= \_AuthSource;

@GET('v1/auth/sign-in')  
Future\<BaseDto\> login(@Body() LoginDto model);  
}

### **Dependency Injection (Modules)**

Register all external dependencies (like Dio) and your Source files in the dependency\_manager/modules.dart file.

@module  
abstract class AppModule {  
@lazySingleton  
Dio dio(NetworkInterceptor interceptor) {  
final dio \= Dio();  
// ... configuration (baseUrl, timeouts, interceptors)  
return dio;  
}

@lazySingleton  
AuthSource authSource(Dio dio) \=\> AuthSource(dio);  
}

**Note:** Always run the build runner to generate necessary files:

flutter pub run build\_runner build \--delete-conflicting-outputs

## **2\. The Domain Layer**

The Domain layer contains the business logic and defines how data should be accessed.

### **Repositories**

Repositories act as the gateway for the Presentation layer.

* **Rule:** They must be @lazySingleton.
* **Rule:** They depend on Sources or Services (e.g., FirebaseMessagingService).
* **Rule:** They must wrap all calls in ApiResultWrapper.

@lazySingleton  
class AuthRepository {  
AuthRepository(this.\_source);  
final AuthSource \_source;

Future\<ApiResult\<LoginResponseModel\>\> login(LoginDto model) async {  
return ApiResultWrapper.wrap(  
func: () \=\> \_source.login(model),  
mapper: (json) \=\> LoginResponseModel.fromJson(json),  
);  
}  
}

## **3\. The Presentation Layer (Stores)**

Stores communicate with Repositories to update the UI state.

### **Injection in Stores**

**Never use a Source directly in a Store.** Always go through a Repository.

@lazySingleton  
class AccountStore \= \_AccountStore with \_$AccountStore;

abstract class \_AccountStore with Store {
\_AccountStore()
: \_repository \= getIt\<AccountRepository\>(),  
\_localRepository \= getIt\<LocalAccountRepository\>();

final AccountRepository \_repository;  
final LocalAccountRepository \_localRepository;  
}

### **Reactive State Management (Status Observables)**

For every asynchronous operation, you must define an @observable to track its progress. This allows the UI to show loaders or error messages automatically.

@observable  
Status getUserAccountStatus \= Status.initial;

@observable  
String? error;

@observable  
Account? account;

## **4\. The ApiResult Pattern**

We use a sealed class for API responses to force the developer to handle both Success and Failure cases.

### **The Structure**

ApiResult\<T\> can be either a Success\<T\> (containing the data) or a Failure\<T\> (containing error messages and codes).

### **Usage in the Store**

Using the .when() method is mandatory. It ensures that you don't accidentally try to access data when the request has failed.

@action  
Future\<void\> getUserAccount() async {  
// 1\. Set status to loading  
getUserAccountStatus \= Status.loading;  
error \= null;

final response \= await \_repository.getUserAccount();

// 2\. Handle response via .when()  
response.when(  
onSuccess: (result) {  
\_localRepository.saveUser(result);  
account \= result;  
getUserAccountStatus \= Status.success;  
},  
onError: (errorMessage) {  
error \= errorMessage;  
getUserAccountStatus \= Status.error;  
NotifyHelper.showErrorToast(errorMessage);  
},  
);  
}

### **Why this is important:**

1. **Type Safety:** You cannot access the success data without first checking the result type.
2. **Consistency:** Every API call in the app handles errors, loading states, and success data in the exact same way.
3. **Clean UI:** It makes it trivial to show different UI components (loaders, error dialogs) based on the Status and the ApiResult.