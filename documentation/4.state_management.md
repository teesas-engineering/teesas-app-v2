# **State Management Guide**

This project utilizes **MobX** for reactive state management. Our goal is to maintain a clear separation between UI and business logic while ensuring high performance through granular rebuilds.

## **1\. Directory Structure**

To maintain consistency, follow these path conventions:

* **Feature-specific Stores:** /lib/features/.../stores/
* **Shared Stores:** /\_shared/stores/ (Used for state shared across multiple features).

## **2\. Reusable Shared Stores**

We provide two lightweight, generic stores in /\_shared/stores for common primitive state needs:

1. **ToggleStore:** Holds a single boolean state (e.g., for visibility, loading states, or switches).
2. **IndexStore:** Holds a single integer state (e.g., for tab indices, page numbers, or selection counters).

## **3\. Understanding Observables**

Observables are the "heart" of MobX. They represent the reactive data that the UI "tracks."

### **Observable Types**

* **Observable (Standard):** Used for primitives (bool, int, String) or simple objects.
* **ObservableList:** Use this instead of List to track when items are added, removed, or moved.
* **ObservableMap:** Use this instead of Map to track key/value changes.

### **The Project Rule of Thumb**

**Granular Observers:** Do not wrap your entire widget tree in an Observer. Only wrap the specific, smallest possible widget that needs to change when the data updates. This prevents unnecessary rebuilds of static UI elements.

## **4\. Encapsulating Logic & Controllers**

**Priority Rule:** Avoid using setState anywhere in the app.

All logic must reside in the Store. This includes UI-related controllers that are traditionally kept in a StatefulWidget:

* **TextEditingControllers:** Define and manage them in the store.
* **PageControllers:** Handle navigation indices and animations in the store.
* **FormKeys:** Even GlobalKey\<FormState\> should be managed in the store to allow the store to trigger validation logic.

### **Example: Store with Controllers**

class LoginStore \= \_LoginStoreBase with \_$LoginStore;

abstract class \_LoginStoreBase with Store {  
final loginFormKey \= GlobalKey\<FormState\>();  
final emailController \= TextEditingController();

@observable  
bool isLoading \= false;

@action  
void validateAndSubmit() {  
if (loginFormKey.currentState?.validate() ?? false) {  
// Perform logic...  
}  
}  
}

## **5\. Shared State in Stateless Widgets**

To use shared state (via Provider) without using a StatefulWidget, follow the **Parent-Child Stateless Pattern**. This ensures the Provider is available in the context when the child tries to access it.

1. **Parent Widget:** Responsible for injecting the Provider.
2. **Child Widget:** Holds the actual UI tree and consumes the store.

// 1\. The Parent  
class ProfilePage extends StatelessWidget {  
@override  
Widget build(BuildContext context) {  
return Provider\<ProfileStore\>(  
create: (\_) \=\> getIt\<ProfileStore\>(),  
child: const \_ProfileContent(), // The child  
);  
}  
}

// 2\. The Child  
class \_ProfileContent extends StatelessWidget {  
const \_ProfileContent();

@override  
Widget build(BuildContext context) {  
final store \= Provider.of\<ProfileStore\>(context);  
return Observer(  
builder: (\_) \=\> Text(store.userName),  
);  
}  
}

## **6\. Action Method Constraints**

To keep the architecture clean and predictable:

* **Max 1 Argument:** Action methods should ideally accept **at most one argument**.
* **Why?** This encourages creating specialized actions or passing simple data transfer objects (DTOs) rather than complex, multi-parameter methods that are hard to debug and track.
* **Exception:** Only pass multiple arguments if it is absolutely necessary for the operation's atomicity.

// GOOD  
@action  
void updateEmail(String email) \=\> userEmail \= email;

// AVOID  
@action  
void updateUserDetails(String name, String email, int age, String address) { ... }

## **7\. Summary of Best Practices**

1. **Zero setState:** If you need a variable to change the UI, it belongs in a Store.
2. **Store \= Truth:** Everything from API data to TextEditingControllers lives in the Store.
3. **Small Observers:** Keep Observer widgets as deep in the tree as possible.
4. **Dispose:** Ensure controllers (like TextEditingController) are disposed of by the Store if the store is not a singleton.