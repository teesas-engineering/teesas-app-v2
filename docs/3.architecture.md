# Project Architecture Guide

This document describes the architectural principles, rules, and patterns used in this project.  
It is intended to be a **single source of truth** for developers working on the codebase.

---

## Architecture Overview

This project follows a strict **Layered Architecture**:

```
Data → Domain → Presentation
```

### Core Goals
- Scalability
- Testability
- Clear separation of concerns
- Predictable data flow

### Dependency Rule
Lower layers **must never** depend on higher layers.

| Layer | Responsibility |
|------|----------------|
| Data | Fetching & mapping external data |
| Domain | Business logic & orchestration |
| Presentation | UI state & user interaction |

---

## 1. The Data Layer

The Data Layer is responsible for fetching and mapping raw data from external sources such as APIs or SDKs.

### Folder Structure
```
data/
 ├── dto/
 ├── model/
 └── source/
```

---

### DTO vs Model

#### DTO (Data Transfer Object)
- Location: `data/dto/`
- Matches backend JSON **exactly**
- Volatile and backend-dependent
- Contains no logic

#### Model
- Location: `data/model/`
- Internal app representation
- May flatten or normalize DTOs
- May include helper methods

---

### Remote Data Sources (Retrofit)

All API calls are handled using **Retrofit**.

Rules:
- Sources must be abstract classes
- No business logic
- No error handling
- No state management

```dart
@RestApi()
abstract class AuthSource {
  factory AuthSource(Dio dio) = _AuthSource;

  @GET('v1/auth/sign-in')
  Future<BaseDto> login(@Body() LoginDto model);
}
```

---

### Dependency Injection (Modules)

All external dependencies and Sources must be registered in:

```
dependency_manager/modules.dart
```

```dart
@module
abstract class AppModule {
  @lazySingleton
  Dio dio(NetworkInterceptor interceptor) {
    final dio = Dio();
    // baseUrl, timeouts, interceptors
    return dio;
  }

  @lazySingleton
  AuthSource authSource(Dio dio) => AuthSource(dio);
}
```

#### Build Runner

Always run after DI or Retrofit changes:

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

---

## 2. The Domain Layer

The Domain Layer contains all business logic and defines how data is accessed.

---

### Repositories

Repositories act as the **single gateway** to the Data layer.

#### Repository Rules
- Must be annotated with `@lazySingleton`
- May depend on Sources or Services
- Must wrap all calls with `ApiResultWrapper`
- Must return **Models**, never DTOs

```dart
@lazySingleton
class AuthRepository {
  AuthRepository(this._source);

  final AuthSource _source;

  Future<ApiResult<LoginResponseModel>> login(LoginDto model) async {
    return ApiResultWrapper.wrap(
      func: () => _source.login(model),
      mapper: (json) => LoginResponseModel.fromJson(json),
    );
  }
}
```

---

## 3. The Presentation Layer (Stores)

Stores manage UI state and communicate exclusively with Repositories.

---

### Injection Rules

❌ Never inject a Source into a Store  
✅ Always inject Repositories

```dart
@lazySingleton
class AccountStore = _AccountStore with _$AccountStore;

abstract class _AccountStore with Store {
  _AccountStore()
      : _repository = getIt<AccountRepository>(),
        _localRepository = getIt<LocalAccountRepository>();

  final AccountRepository _repository;
  final LocalAccountRepository _localRepository;
}
```

---

### Reactive State Management

Every async operation **must** expose a Status observable.

```dart
@observable
Status getUserAccountStatus = Status.initial;

@observable
String? error;

@observable
Account? account;
```

---

## 4. The ApiResult Pattern

All API responses are wrapped in a sealed `ApiResult<T>` type.

### Structure
- `Success<T>` → contains data
- `Failure<T>` → contains error information

---

### Usage in Stores

The `.when()` method is **mandatory**.

```dart
@action
Future<void> getUserAccount() async {
  getUserAccountStatus = Status.loading;
  error = null;

  final response = await _repository.getUserAccount();

  response.when(
    onSuccess: (result) {
      _localRepository.saveUser(result);
      account = result;
      getUserAccountStatus = Status.success;
    },
    onError: (errorMessage) {
      error = errorMessage;
      getUserAccountStatus = Status.error;
      NotifyHelper.showErrorToast(errorMessage);
    },
  );
}
```

---

### Why This Matters

1. **Type Safety** – success data cannot be accessed accidentally
2. **Consistency** – every API call behaves the same way
3. **Clean UI** – loading, error, and success states are predictable
4. **Enforced Discipline** – impossible to skip error handling

---

## Final Notes

This architecture is **non-negotiable**.

If a feature feels difficult to implement, it is usually a sign that:
- A layer boundary is being violated, or
- Logic is in the wrong layer

Fix the structure — not the symptom.
