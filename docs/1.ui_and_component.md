# UI Development Guidelines

This document defines the **architectural, structural, and stylistic standards** for UI development in this project.

The goal is to:
- Keep UI predictable and maintainable
- Enforce a clean separation of responsibilities
- Ensure consistency across all features
- Prevent logic and styling drift over time

---

## Core Philosophy

UI is **declarative and stateless**.  
Business logic, state, and controllers **do not live in UI code**.

This document intentionally distinguishes between **Widgets** and **Components** to prevent UI sprawl and unstructured screens.

---

## 1. UI Taxonomy & Definitions

UI elements are classified into **two distinct categories** based on complexity and responsibility.

---

### Widgets

**Definition**
- Low-level, atomic UI elements
- Single responsibility
- Highly reusable

**Scope**
- Generic
- Minimal or no logic
- Not feature-specific

**Examples**
- `AppButton`
- `CustomTextField`
- `TagChip`
- `LoadingSpinner`

Widgets should be safe to reuse **anywhere in the app** without modification.

---

### Components

**Definition**
- A composition of multiple Widgets
- Represents a complex UI tree or a distinct section of a screen

**Scope**
- Feature-specific
- Use-case driven
- May depend on Stores (via Provider / Observer)

**Examples**
- `UserProfileHeader`
- `TransactionHistoryList`
- `RegistrationForm`

Components are **not** meant to be globally reusable.

---

## 2. Directory Structure

Each feature module must organize its UI according to the taxonomy above.

```
presentation/
 ├── widget/
 ├── components/
 ├── modal/
 └── dialog/
```

### Folder Responsibilities

- **`presentation/widget/`**
  - Atomic, low-level UI elements

- **`presentation/components/`**
  - Complex UI compositions
  - Subscreens
  - Feature-specific sections

- **`presentation/modal/`**
  - Feature-specific Modals

- **`presentation/dialog/`**
  - Feature-specific Dialogs

Misplacing UI elements is considered an architectural violation.

---

## 3. General Implementation Rules

These rules apply to **both Widgets and Components**.

---

### Stateless by Default

- Prefer `StatelessWidget`
- Use `StatefulWidget` **only when strictly necessary**

Allowed use cases:
- `AnimationController`
- Complex local lifecycle handling

❌ Do not use `StatefulWidget` for holding business state

---

### One Class, One File

- Every Widget or Component **must live in its own file**
- Do not define multiple UI classes in a single file

This improves:
- Readability
- Reviewability
- File-level ownership

---

### No Function Components

❌ Do not do this:
```dart
Widget buildHeader() {
  return Text('Header');
}
```

✅ Do this instead:
```dart
class Header extends StatelessWidget {
  const Header({super.key});

  @override
  Widget build(BuildContext context) {
    return Text('Header');
  }
}
```

Function-based UI hides structure and prevents reuse.

---

## 4. Design System Enforcement

The design system is **non-optional**.

---

### Typography

- All text styles **must** come from `AppTypography`
- No inline `TextStyle` definitions

---

### Colors

- All colors **must** come from `AppColors`

❌ Prohibited:
- Hardcoded hex values
- `Colors.blue`, `Colors.red`, etc.

✅ Allowed:
- `AppColors.primary`
- `AppColors.surfaceSecondary`

This ensures theme consistency and future theming support.

---

## 5. Modals and Dialogs

Modals and Dialogs are treated as **first-class UI elements** and must follow strict rules.

---

### Structure Rules

- **Modals**
  - Must be wrapped with `BaseModalParent`

- **Dialogs**
  - Must be wrapped with `BaseDialogParent`

- Default to `StatelessWidget`
- Introduce state only if unavoidable

---

### Triggering Rules

Each Modal or Dialog must expose a **static display method**.

#### Modals
```dart
MyModal.show(context);
```

Internally:
```dart
ModalHelper.show(...);
```

#### Dialogs
```dart
MyDialog.show(context);
```

Internally:
```dart
DialogHelper.show(...);
```

UI code must never call helpers directly.

---

## 6. Review Checklist

Before merging UI-related PRs, confirm the following:

- [ ] Correct classification: Widget vs Component
- [ ] Correct folder placement
- [ ] One UI class per file
- [ ] No function-based UI components
- [ ] `StatelessWidget` by default
- [ ] `AppTypography` used for all text
- [ ] `AppColors` used for all colors
- [ ] Modals and Dialogs follow wrapper + trigger rules

---

## Final Note

If a UI file:
- Feels too large
- Mixes logic and presentation
- Requires frequent refactors

It is usually a sign that:
- A Component should be split, or
- State is leaking into the UI layer

**Fix the structure — not the symptoms.**
