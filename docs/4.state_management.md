# State Management Guide

This document defines the **state management rules and patterns** used in this project.  
We use **MobX** to achieve reactive, predictable, and high‑performance UI updates while maintaining a strict separation between UI and business logic.

---

## Why MobX?

- Clear separation of concerns
- Fine‑grained rebuilds (better performance)
- Explicit, traceable state changes
- Store‑driven architecture (UI is a projection of state)

---

## 1. Directory Structure

To maintain consistency and discoverability, follow these conventions:

```
lib/
 ├── features/
 │    └── <feature_name>/
 │         └── stores/
 └── _shared/
      └── stores/
```

### Rules
- **Feature-specific Stores:**  
  `lib/features/<feature_name>/stores/`
- **Shared Stores:**  
  `lib/_shared/stores/`  
  (Only for state reused across multiple features)

---

## 2. Reusable Shared Stores

The `_shared/stores` directory contains small, generic stores for primitive state needs.

### Available Shared Stores

1. **ToggleStore**
    - Manages a single `bool`
    - Common use cases:
        - Visibility
        - Loading flags
        - Feature toggles

2. **IndexStore**
    - Manages a single `int`
    - Common use cases:
        - Tab indices
        - Page indices
        - Selection counters

These stores should remain **simple, opinionated, and reusable**.

---

## 3. Understanding Observables

Observables are the **core of MobX**.  
They represent reactive data that the UI automatically tracks.

### Observable Types

- **@observable**
    - Primitives (`bool`, `int`, `String`)
    - Simple objects

- **ObservableList**
    - Use instead of `List`
    - Tracks insertions, removals, and reordering

- **ObservableMap**
    - Use instead of `Map`
    - Tracks key/value mutations

---

### Project Rule of Thumb: Granular Observers

❌ Do **not** wrap entire widget trees in an `Observer`  
✅ Wrap the **smallest possible widget** that depends on the observable

**Why?**
- Prevents unnecessary rebuilds
- Keeps static UI fast
- Makes reactive dependencies explicit

---

## 4. Encapsulating Logic & Controllers

### Priority Rule: Zero `setState`

`setState` is **not allowed** in this project.

All logic must live in a **Store**, including UI-related controllers traditionally kept inside `StatefulWidget`s.

### Controllers That Must Live in Stores

- `TextEditingController`
- `PageController`
- `ScrollController`
- `GlobalKey<FormState>`

This allows:
- Validation from the Store
- Better testability
- Stateless UI components

---

### Example: Store with Controllers

```dart
class LoginStore = _LoginStoreBase with _$LoginStore;

abstract class _LoginStoreBase with Store {
  final loginFormKey = GlobalKey<FormState>();
  final emailController = TextEditingController();

  @observable
  bool isLoading = false;

  @action
  void validateAndSubmit() {
    if (loginFormKey.currentState?.validate() ?? false) {
      // Perform business logic
    }
  }
}
```

---

## 5. Shared State in Stateless Widgets

To use shared state without converting widgets to `StatefulWidget`, use the **Parent–Child Stateless Pattern**.

### Pattern Overview

1. **Parent Widget**
    - Injects the Store using `Provider`
2. **Child Widget**
    - Consumes the Store
    - Contains the actual UI tree

---

### Example

```dart
// 1. Parent
class ProfilePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Provider<ProfileStore>(
      create: (_) => getIt<ProfileStore>(),
      child: const _ProfileContent(),
    );
  }
}

// 2. Child
class _ProfileContent extends StatelessWidget {
  const _ProfileContent();

  @override
  Widget build(BuildContext context) {
    final store = Provider.of<ProfileStore>(context);

    return Observer(
      builder: (_) => Text(store.userName),
    );
  }
}
```

This guarantees the Provider is available **before** the UI attempts to read from it.

---

## 6. Action Method Constraints

To keep Stores predictable and easy to reason about:

### Rules

- **Maximum 1 argument per @action**
- Prefer:
    - Specialized actions
    - Simple DTOs
- Avoid:
    - Large parameter lists
    - God-methods

### Examples

✅ **Good**
```dart
@action
void updateEmail(String email) => userEmail = email;
```

❌ **Avoid**
```dart
@action
void updateUserDetails(
  String name,
  String email,
  int age,
  String address,
) {
  // Too many responsibilities
}
```

---

## 7. Disposal Rules

If a Store is **not** a singleton:

- It **must** dispose of:
    - `TextEditingController`
    - `PageController`
    - Any stream or subscription

```dart
void dispose() {
  emailController.dispose();
}
```

---

## 8. Summary of Best Practices

1. **Zero setState** – UI reacts to Stores only
2. **Store = Source of Truth** – API data, controllers, flags
3. **Granular Observers** – rebuild only what must change
4. **Stateless UI** – UI renders, Stores decide
5. **Explicit Actions** – predictable and debuggable state changes

---

## Final Note

If UI behavior feels complex or fragile, it usually means:
- State is leaking into the UI, or
- Logic belongs in a Store but isn't

**Fix the architecture — not the widget.**
