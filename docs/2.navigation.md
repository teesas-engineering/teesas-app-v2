# Navigation & Routing Guide

This document defines the **navigation and routing architecture** for the project.

We use **go_router** combined with **injectable** and **get_it** to enforce a service-oriented navigation model that cleanly separates:
- Route configuration
- Navigation logic
- UI concerns

---

## Why This Approach?

- Centralized route definitions
- Semantic, readable navigation calls
- No `BuildContext`-driven navigation in UI
- Easy refactoring and testing
- Consistent back-stack behavior

---

## 1. Architecture Overview

The navigation system is built on **two core classes**.

### MainRouter (`@singleton`)

**Responsibilities**
- Defines all route path constants
- Configures the `GoRouter` instance
- Owns the route tree
- Maps paths to Screens / Widgets

```dart
@singleton
class MainRouter {
  late final GoRouter router;

  // Route path constants live here
}
```

---

### RouteHelper (`@lazySingleton`)

**Responsibilities**
- Acts as the navigation controller
- Exposes semantic navigation methods
- Abstracts `go_router` internals
- Prevents UI from depending on routing APIs

```dart
@lazySingleton
class RouteHelper {
  final MainRouter mainRouter;

  RouteHelper(this.mainRouter);
}
```

---

## 2. Usage in UI

### Core Rule

❌ **Never** use:
- `Navigator.of(context)`
- `GoRouter.of(context)`
- `context.go(...)`
- `context.push(...)`

✅ **Always** use `RouteHelper` via `getIt`.

---

### Basic Navigation

```dart
// Navigate to a new screen
getIt<RouteHelper>().showLoginScreen();

// Navigate and replace current screen (no back button)
getIt<RouteHelper>().showOnboardingRoot(replace: true);

// Go back
getIt<RouteHelper>().pop();

// Go back with a result
getIt<RouteHelper>().pop(true);
```

---

### Overlays (Non-route Based)

For simple overlays that should not be part of the navigation stack:

```dart
final overlay = getIt<RouteHelper>()
    .showOverlay(MyCustomWidget(), context);

// Remove overlay later
getIt<RouteHelper>().hideOverlay(overlay);
```

Overlays are still managed centrally to avoid UI-level state leaks.

---

## 3. Workflow: Adding a New Route

Adding a new screen follows a **strict 3-step process**.

---

### Step 1: Define the Path Constant

Open:

```
lib/.../navigation/main_router.dart
```

Add a static route constant.

```dart
@singleton
class MainRouter {
  // Existing routes
  static const String profileScreen = '/profile';
}
```

---

### Step 2: Register the Route

In the same `MainRouter`, register a `GoRoute` using the constant.

```dart
late final GoRouter _router = GoRouter(
  routes: [
    // Existing routes

    GoRoute(
      path: profileScreen,
      name: profileScreen,
      builder: (context, state) => const ProfileScreen(),
    ),
  ],
);
```

**Rules**
- Always use the constant for both `path` and `name`
- Do not inline strings

---

### Step 3: Create the Helper Method

Open:

```
lib/.../navigation/route_helper.dart
```

Add a semantic navigation method.

```dart
@lazySingleton
class RouteHelper {
  // Existing methods

  void showProfileScreen({bool replace = false}) {
    if (replace) {
      mainRouter.router.replaceNamed(MainRouter.profileScreen);
    } else {
      mainRouter.router.pushNamed(MainRouter.profileScreen);
    }
  }
}
```

This guarantees:
- Type safety
- Consistent navigation behavior
- Easy refactoring

---

## 4. Guidelines & Rules

### Naming
- Route constants must reflect URL structure
- Example: `/user-details`, `/account/settings`

### Named Navigation Only
- Always use `pushNamed` / `replaceNamed`
- Never navigate via raw paths in UI

### Encapsulation
- UI Widgets **must not** know about `go_router`
- All navigation logic belongs in `RouteHelper`

### Dependency Injection
- `MainRouter` must be injected into `RouteHelper`
- Never instantiate routers manually

---

## Anti-Patterns (Do Not Do This)

❌ Navigation inside widgets using `context.go()`  
❌ Hardcoded route strings  
❌ Business logic inside route builders  
❌ Multiple routers in the app

---

## Final Note

If navigation feels confusing or inconsistent, it usually means:
- A route is being triggered outside `RouteHelper`, or
- Routing logic has leaked into the UI layer

**Fix the architecture — not the widget.**
